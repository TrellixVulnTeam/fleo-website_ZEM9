{"ast":null,"code":"import _classCallCheck from \"/Users/abhinavsrinivas/programming/projects/FLEO/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/abhinavsrinivas/programming/projects/FLEO/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Observable, of, from } from 'rxjs';\nimport { debounceTime, map, observeOn, switchMap } from 'rxjs/operators';\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, Pipe, ChangeDetectorRef, NgModule } from '@angular/core';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵfetchInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport 'firebase/storage';\nimport { AsyncPipe } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * Generated from: observable/fromTask.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\n\n/**\n * @param {?} task\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction fromTask(task) {\n  return new Observable(\n  /**\n  * @param {?} subscriber\n  * @return {?}\n  */\n\n  /**\n  * @param {?} subscriber\n  * @return {?}\n  */\n  function (subscriber) {\n    /** @type {?} */\n    var progress =\n    /**\n    * @param {?} snap\n    * @return {?}\n    */\n    function progress(snap) {\n      return subscriber.next(snap);\n    };\n    /** @type {?} */\n\n\n    var error =\n    /**\n    * @param {?} e\n    * @return {?}\n    */\n\n    /**\n    * @param {?} e\n    * @return {?}\n    */\n    function error(e) {\n      return subscriber.error(e);\n    };\n    /** @type {?} */\n\n\n    var complete =\n    /**\n    * @return {?}\n    */\n    function complete() {\n      return subscriber.complete();\n    }; // emit the current snapshot, so they don't have to wait for state_changes\n    // to fire next... this is stale if the task is no longer running :(\n\n\n    progress(task.snapshot);\n    /** @type {?} */\n\n    var unsub = task.on('state_changed', progress); // it turns out that neither task snapshot nor 'state_changed' fire the last\n    // snapshot before completion, the one with status 'success\" and 100% progress\n    // so let's use the promise form of the task for that\n\n    task.then(\n    /**\n    * @param {?} snapshot\n    * @return {?}\n    */\n\n    /**\n    * @param {?} snapshot\n    * @return {?}\n    */\n    function (snapshot) {\n      progress(snapshot);\n      complete();\n    },\n    /**\n    * @param {?} e\n    * @return {?}\n    */\n\n    /**\n    * @param {?} e\n    * @return {?}\n    */\n    function (e) {\n      // TODO investigate, again this is stale, we never fire a canceled or error it seems\n      progress(task.snapshot);\n      error(e);\n    }); // on's type if Function, rather than () => void, need to wrap\n\n    return (\n      /**\n      * @return {?}\n      */\n      function unsubscribe() {\n        unsub();\n      }\n    );\n  }).pipe( // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n  // that if the task is already finished we don't emit the old running state\n  debounceTime(0));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: task.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction AngularFireUploadTask() {}\n\nif (false) {\n  /** @type {?} */\n  AngularFireUploadTask.prototype.task;\n  /**\n   * @return {?}\n   */\n\n  AngularFireUploadTask.prototype.snapshotChanges = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.percentageChanges = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.pause = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.cancel = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.resume = function () {};\n  /**\n   * @param {?=} onFulfilled\n   * @param {?=} onRejected\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.then = function (onFulfilled, onRejected) {};\n  /**\n   * @param {?} onRejected\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.catch = function (onRejected) {};\n}\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n * @param {?} task\n * @return {?}\n */\n\n\nfunction createUploadTask(task) {\n  /** @type {?} */\n  var inner$ = fromTask(task);\n  return {\n    task: task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges:\n    /**\n    * @return {?}\n    */\n    function snapshotChanges() {\n      return inner$;\n    },\n    percentageChanges:\n    /**\n    * @return {?}\n    */\n    function percentageChanges() {\n      return inner$.pipe(map(\n      /**\n      * @param {?} s\n      * @return {?}\n      */\n\n      /**\n      * @param {?} s\n      * @return {?}\n      */\n      function (s) {\n        return s.bytesTransferred / s.totalBytes * 100;\n      }));\n    }\n  };\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: ref.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction AngularFireStorageReference() {}\n\nif (false) {\n  /**\n   * @return {?}\n   */\n  AngularFireStorageReference.prototype.getDownloadURL = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.getMetadata = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.delete = function () {};\n  /**\n   * @param {?} path\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.child = function (path) {};\n  /**\n   * @param {?} meta\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.updateMetadata = function (meta) {};\n  /**\n   * @param {?} data\n   * @param {?=} metadata\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.put = function (data, metadata) {};\n  /**\n   * @param {?} data\n   * @param {?=} format\n   * @param {?=} metadata\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.putString = function (data, format, metadata) {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.listAll = function () {};\n}\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n * @param {?} ref\n * @param {?} schedulers\n * @param {?} keepUnstableUntilFirst\n * @return {?}\n */\n\n\nfunction createStorageRef(ref, schedulers, keepUnstableUntilFirst) {\n  return {\n    getDownloadURL:\n    /**\n    * @return {?}\n    */\n    function getDownloadURL() {\n      return of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(\n      /**\n      * @return {?}\n      */\n      function () {\n        return ref.getDownloadURL();\n      }), keepUnstableUntilFirst);\n    },\n    getMetadata:\n    /**\n    * @return {?}\n    */\n    function getMetadata() {\n      return of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(\n      /**\n      * @return {?}\n      */\n      function () {\n        return ref.getMetadata();\n      }), keepUnstableUntilFirst);\n    },\n    delete:\n    /**\n    * @return {?}\n    */\n    function _delete() {\n      return from(ref.delete());\n    },\n    child:\n    /**\n    * @param {?} path\n    * @return {?}\n    */\n    function child(path) {\n      return createStorageRef(ref.child(path), schedulers, keepUnstableUntilFirst);\n    },\n    updateMetadata:\n    /**\n    * @param {?} meta\n    * @return {?}\n    */\n    function updateMetadata(meta) {\n      return from(ref.updateMetadata(meta));\n    },\n    put:\n    /**\n    * @param {?} data\n    * @param {?=} metadata\n    * @return {?}\n    */\n    function put(data, metadata) {\n      /** @type {?} */\n      var task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString:\n    /**\n    * @param {?} data\n    * @param {?=} format\n    * @param {?=} metadata\n    * @return {?}\n    */\n    function putString(data, format, metadata) {\n      /** @type {?} */\n      var task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    },\n    listAll:\n    /**\n    * @return {?}\n    */\n    function listAll() {\n      return from(ref.listAll());\n    }\n  };\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: storage.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar BUCKET = new InjectionToken('angularfire2.storageBucket');\n/** @type {?} */\n\nvar MAX_UPLOAD_RETRY_TIME = new InjectionToken('angularfire2.storage.maxUploadRetryTime');\n/** @type {?} */\n\nvar MAX_OPERATION_RETRY_TIME = new InjectionToken('angularfire2.storage.maxOperationRetryTime');\n\nvar AngularFireStorage = /*@__PURE__*/function () {\n  var AngularFireStorage = /*#__PURE__*/function () {\n    /**\n     * @param {?} options\n     * @param {?} nameOrConfig\n     * @param {?} storageBucket\n     * @param {?} platformId\n     * @param {?} zone\n     * @param {?} maxUploadRetryTime\n     * @param {?} maxOperationRetryTime\n     */\n    function AngularFireStorage(options, nameOrConfig, storageBucket, // tslint:disable-next-line:ban-types\n    platformId, zone, maxUploadRetryTime, maxOperationRetryTime) {\n      _classCallCheck(this, AngularFireStorage);\n\n      this.schedulers = new ɵAngularFireSchedulers(zone);\n      this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n      /** @type {?} */\n\n      var app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n      this.storage = ɵfetchInstance(\"\".concat(app.name, \".storage.\").concat(storageBucket), 'AngularFireStorage', app,\n      /**\n      * @return {?}\n      */\n      function () {\n        /** @type {?} */\n        var storage = zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          return app.storage(storageBucket || undefined);\n        });\n\n        if (maxUploadRetryTime) {\n          storage.setMaxUploadRetryTime(maxUploadRetryTime);\n        }\n\n        if (maxOperationRetryTime) {\n          storage.setMaxOperationRetryTime(maxOperationRetryTime);\n        }\n\n        return storage;\n      }, [maxUploadRetryTime, maxOperationRetryTime]);\n    }\n    /**\n     * @param {?} path\n     * @return {?}\n     */\n\n\n    _createClass(AngularFireStorage, [{\n      key: \"ref\",\n      value: function ref(path) {\n        return createStorageRef(this.storage.ref(path), this.schedulers, this.keepUnstableUntilFirst);\n      }\n      /**\n       * @param {?} path\n       * @return {?}\n       */\n\n    }, {\n      key: \"refFromURL\",\n      value: function refFromURL(path) {\n        return createStorageRef(this.storage.refFromURL(path), this.schedulers, this.keepUnstableUntilFirst);\n      }\n      /**\n       * @param {?} path\n       * @param {?} data\n       * @param {?=} metadata\n       * @return {?}\n       */\n\n    }, {\n      key: \"upload\",\n      value: function upload(path, data, metadata) {\n        /** @type {?} */\n        var storageRef = this.storage.ref(path);\n        /** @type {?} */\n\n        var ref = createStorageRef(storageRef, this.schedulers, this.keepUnstableUntilFirst);\n        return ref.put(data, metadata);\n      }\n    }]);\n\n    return AngularFireStorage;\n  }();\n\n  AngularFireStorage.ɵfac = function AngularFireStorage_Factory(t) {\n    return new (t || AngularFireStorage)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(BUCKET, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), ɵngcc0.ɵɵinject(MAX_OPERATION_RETRY_TIME, 8));\n  };\n  /** @nocollapse */\n\n\n  AngularFireStorage.ɵprov = ɵɵdefineInjectable({\n    factory: function AngularFireStorage_Factory() {\n      return new AngularFireStorage(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(BUCKET, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone), ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), ɵɵinject(MAX_OPERATION_RETRY_TIME, 8));\n    },\n    token: AngularFireStorage,\n    providedIn: \"any\"\n  });\n  return AngularFireStorage;\n}();\n\nif (false) {\n  /** @type {?} */\n  AngularFireStorage.prototype.storage;\n  /** @type {?} */\n\n  AngularFireStorage.prototype.keepUnstableUntilFirst;\n  /** @type {?} */\n\n  AngularFireStorage.prototype.schedulers;\n}\n\nvar GetDownloadURLPipe = /*@__PURE__*/function () {\n  var GetDownloadURLPipe = /*#__PURE__*/function () {\n    /**\n     * @param {?} storage\n     * @param {?} cdr\n     */\n    function GetDownloadURLPipe(storage, cdr) {\n      _classCallCheck(this, GetDownloadURLPipe);\n\n      this.storage = storage;\n      this.asyncPipe = new AsyncPipe(cdr);\n    }\n    /**\n     * @param {?} path\n     * @return {?}\n     */\n\n\n    _createClass(GetDownloadURLPipe, [{\n      key: \"transform\",\n      value: function transform(path) {\n        if (path !== this.path) {\n          this.path = path;\n          this.downloadUrl$ = this.storage.ref(path).getDownloadURL();\n        }\n\n        return this.asyncPipe.transform(this.downloadUrl$);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.asyncPipe.ngOnDestroy();\n      }\n    }]);\n\n    return GetDownloadURLPipe;\n  }();\n\n  GetDownloadURLPipe.ɵfac = function GetDownloadURLPipe_Factory(t) {\n    return new (t || GetDownloadURLPipe)(ɵngcc0.ɵɵdirectiveInject(AngularFireStorage), ɵngcc0.ɵɵinjectPipeChangeDetectorRef());\n  };\n\n  GetDownloadURLPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({\n    name: \"getDownloadURL\",\n    type: GetDownloadURLPipe,\n    pure: false\n  });\n  return GetDownloadURLPipe;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  GetDownloadURLPipe.prototype.asyncPipe;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  GetDownloadURLPipe.prototype.path;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  GetDownloadURLPipe.prototype.downloadUrl$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  GetDownloadURLPipe.prototype.storage;\n}\n\nvar GetDownloadURLPipeModule = /*@__PURE__*/function () {\n  var GetDownloadURLPipeModule = function GetDownloadURLPipeModule() {\n    _classCallCheck(this, GetDownloadURLPipeModule);\n  };\n\n  GetDownloadURLPipeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: GetDownloadURLPipeModule\n  });\n  GetDownloadURLPipeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function GetDownloadURLPipeModule_Factory(t) {\n      return new (t || GetDownloadURLPipeModule)();\n    }\n  });\n  return GetDownloadURLPipeModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GetDownloadURLPipeModule, {\n    declarations: [GetDownloadURLPipe],\n    exports: [GetDownloadURLPipe]\n  });\n})();\n\nvar AngularFireStorageModule = /*@__PURE__*/function () {\n  var AngularFireStorageModule = function AngularFireStorageModule() {\n    _classCallCheck(this, AngularFireStorageModule);\n  };\n\n  AngularFireStorageModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireStorageModule\n  });\n  AngularFireStorageModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function AngularFireStorageModule_Factory(t) {\n      return new (t || AngularFireStorageModule)();\n    },\n    providers: [AngularFireStorage],\n    imports: [GetDownloadURLPipeModule]\n  });\n  return AngularFireStorageModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AngularFireStorageModule, {\n    exports: [GetDownloadURLPipeModule]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire-storage.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFireStorage, AngularFireStorageModule, BUCKET, GetDownloadURLPipe, GetDownloadURLPipeModule, MAX_OPERATION_RETRY_TIME, MAX_UPLOAD_RETRY_TIME, createStorageRef, createUploadTask, fromTask };","map":null,"metadata":{},"sourceType":"module"}
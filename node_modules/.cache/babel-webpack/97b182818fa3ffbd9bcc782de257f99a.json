{"ast":null,"code":"import _classCallCheck from \"/Users/satvikeltepu/Desktop/Code/fleo-website-1/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/satvikeltepu/Desktop/Code/fleo-website-1/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Observable, of, from } from 'rxjs';\nimport { debounceTime, map, observeOn, switchMap } from 'rxjs/operators';\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, Pipe, ChangeDetectorRef, NgModule } from '@angular/core';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵfetchInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport 'firebase/storage';\nimport { AsyncPipe } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * Generated from: observable/fromTask.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\n\n/**\n * @param {?} task\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction fromTask(task) {\n  return new Observable(\n  /**\n  * @param {?} subscriber\n  * @return {?}\n  */\n  function (subscriber) {\n    /** @type {?} */\n    var progress =\n    /**\n    * @param {?} snap\n    * @return {?}\n    */\n    function progress(snap) {\n      return subscriber.next(snap);\n    };\n    /** @type {?} */\n\n\n    var error =\n    /**\n    * @param {?} e\n    * @return {?}\n    */\n    function error(e) {\n      return subscriber.error(e);\n    };\n    /** @type {?} */\n\n\n    var complete =\n    /**\n    * @return {?}\n    */\n    function complete() {\n      return subscriber.complete();\n    }; // emit the current snapshot, so they don't have to wait for state_changes\n    // to fire next... this is stale if the task is no longer running :(\n\n\n    progress(task.snapshot);\n    /** @type {?} */\n\n    var unsub = task.on('state_changed', progress); // it turns out that neither task snapshot nor 'state_changed' fire the last\n    // snapshot before completion, the one with status 'success\" and 100% progress\n    // so let's use the promise form of the task for that\n\n    task.then(\n    /**\n    * @param {?} snapshot\n    * @return {?}\n    */\n    function (snapshot) {\n      progress(snapshot);\n      complete();\n    },\n    /**\n    * @param {?} e\n    * @return {?}\n    */\n    function (e) {\n      // TODO investigate, again this is stale, we never fire a canceled or error it seems\n      progress(task.snapshot);\n      error(e);\n    }); // on's type if Function, rather than () => void, need to wrap\n\n    return (\n      /**\n      * @return {?}\n      */\n      function unsubscribe() {\n        unsub();\n      }\n    );\n  }).pipe( // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n  // that if the task is already finished we don't emit the old running state\n  debounceTime(0));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: task.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction AngularFireUploadTask() {}\n\nif (false) {\n  /** @type {?} */\n  AngularFireUploadTask.prototype.task;\n  /**\n   * @return {?}\n   */\n\n  AngularFireUploadTask.prototype.snapshotChanges = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.percentageChanges = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.pause = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.cancel = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.resume = function () {};\n  /**\n   * @param {?=} onFulfilled\n   * @param {?=} onRejected\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.then = function (onFulfilled, onRejected) {};\n  /**\n   * @param {?} onRejected\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.catch = function (onRejected) {};\n}\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n * @param {?} task\n * @return {?}\n */\n\n\nfunction createUploadTask(task) {\n  /** @type {?} */\n  var inner$ = fromTask(task);\n  return {\n    task: task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges:\n    /**\n    * @return {?}\n    */\n    function snapshotChanges() {\n      return inner$;\n    },\n    percentageChanges:\n    /**\n    * @return {?}\n    */\n    function percentageChanges() {\n      return inner$.pipe(map(\n      /**\n      * @param {?} s\n      * @return {?}\n      */\n      function (s) {\n        return s.bytesTransferred / s.totalBytes * 100;\n      }));\n    }\n  };\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: ref.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction AngularFireStorageReference() {}\n\nif (false) {\n  /**\n   * @return {?}\n   */\n  AngularFireStorageReference.prototype.getDownloadURL = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.getMetadata = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.delete = function () {};\n  /**\n   * @param {?} path\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.child = function (path) {};\n  /**\n   * @param {?} meta\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.updateMetadata = function (meta) {};\n  /**\n   * @param {?} data\n   * @param {?=} metadata\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.put = function (data, metadata) {};\n  /**\n   * @param {?} data\n   * @param {?=} format\n   * @param {?=} metadata\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.putString = function (data, format, metadata) {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.listAll = function () {};\n}\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n * @param {?} ref\n * @param {?} schedulers\n * @param {?} keepUnstableUntilFirst\n * @return {?}\n */\n\n\nfunction createStorageRef(ref, schedulers, keepUnstableUntilFirst) {\n  return {\n    getDownloadURL:\n    /**\n    * @return {?}\n    */\n    function getDownloadURL() {\n      return of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(\n      /**\n      * @return {?}\n      */\n      function () {\n        return ref.getDownloadURL();\n      }), keepUnstableUntilFirst);\n    },\n    getMetadata:\n    /**\n    * @return {?}\n    */\n    function getMetadata() {\n      return of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(\n      /**\n      * @return {?}\n      */\n      function () {\n        return ref.getMetadata();\n      }), keepUnstableUntilFirst);\n    },\n    delete:\n    /**\n    * @return {?}\n    */\n    function _delete() {\n      return from(ref.delete());\n    },\n    child:\n    /**\n    * @param {?} path\n    * @return {?}\n    */\n    function child(path) {\n      return createStorageRef(ref.child(path), schedulers, keepUnstableUntilFirst);\n    },\n    updateMetadata:\n    /**\n    * @param {?} meta\n    * @return {?}\n    */\n    function updateMetadata(meta) {\n      return from(ref.updateMetadata(meta));\n    },\n    put:\n    /**\n    * @param {?} data\n    * @param {?=} metadata\n    * @return {?}\n    */\n    function put(data, metadata) {\n      /** @type {?} */\n      var task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString:\n    /**\n    * @param {?} data\n    * @param {?=} format\n    * @param {?=} metadata\n    * @return {?}\n    */\n    function putString(data, format, metadata) {\n      /** @type {?} */\n      var task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    },\n    listAll:\n    /**\n    * @return {?}\n    */\n    function listAll() {\n      return from(ref.listAll());\n    }\n  };\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: storage.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar BUCKET = new InjectionToken('angularfire2.storageBucket');\n/** @type {?} */\n\nvar MAX_UPLOAD_RETRY_TIME = new InjectionToken('angularfire2.storage.maxUploadRetryTime');\n/** @type {?} */\n\nvar MAX_OPERATION_RETRY_TIME = new InjectionToken('angularfire2.storage.maxOperationRetryTime');\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\n\nvar AngularFireStorage = /*#__PURE__*/function () {\n  /**\n   * @param {?} options\n   * @param {?} nameOrConfig\n   * @param {?} storageBucket\n   * @param {?} platformId\n   * @param {?} zone\n   * @param {?} maxUploadRetryTime\n   * @param {?} maxOperationRetryTime\n   */\n  function AngularFireStorage(options, nameOrConfig, storageBucket, // tslint:disable-next-line:ban-types\n  platformId, zone, maxUploadRetryTime, maxOperationRetryTime) {\n    _classCallCheck(this, AngularFireStorage);\n\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n    /** @type {?} */\n\n    var app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n    this.storage = ɵfetchInstance(\"\".concat(app.name, \".storage.\").concat(storageBucket), 'AngularFireStorage', app,\n    /**\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var storage = zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        return app.storage(storageBucket || undefined);\n      });\n\n      if (maxUploadRetryTime) {\n        storage.setMaxUploadRetryTime(maxUploadRetryTime);\n      }\n\n      if (maxOperationRetryTime) {\n        storage.setMaxOperationRetryTime(maxOperationRetryTime);\n      }\n\n      return storage;\n    }, [maxUploadRetryTime, maxOperationRetryTime]);\n  }\n  /**\n   * @param {?} path\n   * @return {?}\n   */\n\n\n  _createClass(AngularFireStorage, [{\n    key: \"ref\",\n    value: function ref(path) {\n      return createStorageRef(this.storage.ref(path), this.schedulers, this.keepUnstableUntilFirst);\n    }\n    /**\n     * @param {?} path\n     * @return {?}\n     */\n\n  }, {\n    key: \"refFromURL\",\n    value: function refFromURL(path) {\n      return createStorageRef(this.storage.refFromURL(path), this.schedulers, this.keepUnstableUntilFirst);\n    }\n    /**\n     * @param {?} path\n     * @param {?} data\n     * @param {?=} metadata\n     * @return {?}\n     */\n\n  }, {\n    key: \"upload\",\n    value: function upload(path, data, metadata) {\n      /** @type {?} */\n      var storageRef = this.storage.ref(path);\n      /** @type {?} */\n\n      var ref = createStorageRef(storageRef, this.schedulers, this.keepUnstableUntilFirst);\n      return ref.put(data, metadata);\n    }\n  }]);\n\n  return AngularFireStorage;\n}();\n\nAngularFireStorage.ɵfac = function AngularFireStorage_Factory(t) {\n  return new (t || AngularFireStorage)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(BUCKET, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), ɵngcc0.ɵɵinject(MAX_OPERATION_RETRY_TIME, 8));\n};\n/** @nocollapse */\n\n\nAngularFireStorage.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [FIREBASE_OPTIONS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [FIREBASE_APP_NAME]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [BUCKET]\n    }]\n  }, {\n    type: Object,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }, {\n    type: NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [MAX_UPLOAD_RETRY_TIME]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [MAX_OPERATION_RETRY_TIME]\n    }]\n  }];\n};\n/** @nocollapse */\n\n\nAngularFireStorage.ɵprov = ɵɵdefineInjectable({\n  factory: function AngularFireStorage_Factory() {\n    return new AngularFireStorage(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(BUCKET, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone), ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), ɵɵinject(MAX_OPERATION_RETRY_TIME, 8));\n  },\n  token: AngularFireStorage,\n  providedIn: \"any\"\n});\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AngularFireStorage, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'any'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [FIREBASE_OPTIONS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FIREBASE_APP_NAME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [BUCKET]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAX_UPLOAD_RETRY_TIME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAX_OPERATION_RETRY_TIME]\n      }]\n    }];\n  }, null);\n})();\n\nif (false) {\n  /** @type {?} */\n  AngularFireStorage.prototype.storage;\n  /** @type {?} */\n\n  AngularFireStorage.prototype.keepUnstableUntilFirst;\n  /** @type {?} */\n\n  AngularFireStorage.prototype.schedulers;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: pipes/storageUrl.pipe.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * to be used with in combination with | async\n */\n\n\nvar GetDownloadURLPipe = /*#__PURE__*/function () {\n  /**\n   * @param {?} storage\n   * @param {?} cdr\n   */\n  function GetDownloadURLPipe(storage, cdr) {\n    _classCallCheck(this, GetDownloadURLPipe);\n\n    this.storage = storage;\n    this.asyncPipe = new AsyncPipe(cdr);\n  }\n  /**\n   * @param {?} path\n   * @return {?}\n   */\n\n\n  _createClass(GetDownloadURLPipe, [{\n    key: \"transform\",\n    value: function transform(path) {\n      if (path !== this.path) {\n        this.path = path;\n        this.downloadUrl$ = this.storage.ref(path).getDownloadURL();\n      }\n\n      return this.asyncPipe.transform(this.downloadUrl$);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.asyncPipe.ngOnDestroy();\n    }\n  }]);\n\n  return GetDownloadURLPipe;\n}();\n\nGetDownloadURLPipe.ɵfac = function GetDownloadURLPipe_Factory(t) {\n  return new (t || GetDownloadURLPipe)(ɵngcc0.ɵɵdirectiveInject(AngularFireStorage), ɵngcc0.ɵɵinjectPipeChangeDetectorRef());\n};\n\nGetDownloadURLPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({\n  name: \"getDownloadURL\",\n  type: GetDownloadURLPipe,\n  pure: false\n});\n/** @nocollapse */\n\nGetDownloadURLPipe.ctorParameters = function () {\n  return [{\n    type: AngularFireStorage\n  }, {\n    type: ChangeDetectorRef\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(GetDownloadURLPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'getDownloadURL',\n      pure: false\n    }]\n  }], function () {\n    return [{\n      type: AngularFireStorage\n    }, {\n      type: ɵngcc0.ChangeDetectorRef\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  GetDownloadURLPipe.prototype.asyncPipe;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  GetDownloadURLPipe.prototype.path;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  GetDownloadURLPipe.prototype.downloadUrl$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  GetDownloadURLPipe.prototype.storage;\n}\n\nvar GetDownloadURLPipeModule = function GetDownloadURLPipeModule() {\n  _classCallCheck(this, GetDownloadURLPipeModule);\n};\n\nGetDownloadURLPipeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: GetDownloadURLPipeModule\n});\nGetDownloadURLPipeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function GetDownloadURLPipeModule_Factory(t) {\n    return new (t || GetDownloadURLPipeModule)();\n  }\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GetDownloadURLPipeModule, {\n    declarations: [GetDownloadURLPipe],\n    exports: [GetDownloadURLPipe]\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(GetDownloadURLPipeModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [GetDownloadURLPipe],\n      exports: [GetDownloadURLPipe]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: storage.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar AngularFireStorageModule = function AngularFireStorageModule() {\n  _classCallCheck(this, AngularFireStorageModule);\n};\n\nAngularFireStorageModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: AngularFireStorageModule\n});\nAngularFireStorageModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function AngularFireStorageModule_Factory(t) {\n    return new (t || AngularFireStorageModule)();\n  },\n  providers: [AngularFireStorage],\n  imports: [GetDownloadURLPipeModule]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AngularFireStorageModule, {\n    exports: [GetDownloadURLPipeModule]\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AngularFireStorageModule, [{\n    type: NgModule,\n    args: [{\n      exports: [GetDownloadURLPipeModule],\n      providers: [AngularFireStorage]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire-storage.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFireStorage, AngularFireStorageModule, BUCKET, GetDownloadURLPipe, GetDownloadURLPipeModule, MAX_OPERATION_RETRY_TIME, MAX_UPLOAD_RETRY_TIME, createStorageRef, createUploadTask, fromTask };","map":{"version":3,"sources":["../../../src/storage/observable/fromTask.ts","../../../src/storage/task.ts","../../../src/storage/ref.ts","../../../src/storage/storage.ts","../../../src/storage/pipes/storageUrl.pipe.ts","../../../src/storage/storage.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport { UploadTask, UploadTaskSnapshot } from '../interfaces';\n\n// need to import, else the types become import('firebase/app').default.storage.UploadTask\n// and it no longer works w/Firebase v7\nimport firebase from 'firebase/app';\n\n// Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\nexport function fromTask(task: UploadTask) {\n  return new Observable<UploadTaskSnapshot>(subscriber => {\n    const progress = (snap: UploadTaskSnapshot) => subscriber.next(snap);\n    const error = e => subscriber.error(e);\n    const complete = () => subscriber.complete();\n    // emit the current snapshot, so they don't have to wait for state_changes\n    // to fire next... this is stale if the task is no longer running :(\n    progress(task.snapshot);\n    const unsub = task.on('state_changed', progress);\n    // it turns out that neither task snapshot nor 'state_changed' fire the last\n    // snapshot before completion, the one with status 'success\" and 100% progress\n    // so let's use the promise form of the task for that\n    task.then(snapshot => {\n      progress(snapshot);\n      complete();\n    }, e => {\n      // TODO investigate, again this is stale, we never fire a canceled or error it seems\n      progress(task.snapshot);\n      error(e);\n    });\n    // on's type if Function, rather than () => void, need to wrap\n    return function unsubscribe() {\n      unsub();\n    };\n  }).pipe(\n    // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n    // that if the task is already finished we don't emit the old running state\n    debounceTime(0)\n  );\n}\n","import { UploadTask, UploadTaskSnapshot } from './interfaces';\nimport { fromTask } from './observable/fromTask';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport interface AngularFireUploadTask {\n  task: UploadTask;\n  snapshotChanges(): Observable<UploadTaskSnapshot | undefined>;\n  percentageChanges(): Observable<number | undefined>;\n  pause(): boolean;\n  cancel(): boolean;\n  resume(): boolean;\n  then(\n    onFulfilled?: ((a: UploadTaskSnapshot) => any) | null,\n    onRejected?: ((a: Error) => any) | null\n  ): Promise<any>;\n  catch(onRejected: (a: Error) => any): Promise<any>;\n}\n\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n */\nexport function createUploadTask(task: UploadTask): AngularFireUploadTask {\n  const inner$ = fromTask(task);\n  return {\n    task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges: () => inner$,\n    percentageChanges: () => inner$.pipe(\n      map(s => s.bytesTransferred / s.totalBytes * 100)\n    )\n  };\n}\n","import { ListResult, Reference, SettableMetadata, StringFormat, UploadMetadata } from './interfaces';\nimport { AngularFireUploadTask, createUploadTask } from './task';\nimport { from, Observable, of } from 'rxjs';\nimport { ɵAngularFireSchedulers } from '@angular/fire';\nimport { observeOn, switchMap } from 'rxjs/operators';\n\nexport interface AngularFireStorageReference {\n  getDownloadURL(): Observable<any>;\n  getMetadata(): Observable<any>;\n  delete(): Observable<any>;\n  child(path: string): any;\n  updateMetadata(meta: SettableMetadata): Observable<any>;\n  put(data: any, metadata?: UploadMetadata | undefined): AngularFireUploadTask;\n  putString(data: string, format?: string | undefined, metadata?: UploadMetadata | undefined): AngularFireUploadTask;\n  listAll(): Observable<ListResult>;\n}\n\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n */\nexport function createStorageRef(\n  ref: Reference,\n  schedulers: ɵAngularFireSchedulers,\n  keepUnstableUntilFirst: <T>(obs$: Observable<T>) => Observable<T>\n): AngularFireStorageReference {\n  return {\n    getDownloadURL: () => of(undefined).pipe(\n      observeOn(schedulers.outsideAngular),\n      switchMap(() => ref.getDownloadURL()),\n      keepUnstableUntilFirst\n    ),\n    getMetadata: () => of(undefined).pipe(\n      observeOn(schedulers.outsideAngular),\n      switchMap(() => ref.getMetadata()),\n      keepUnstableUntilFirst\n    ),\n    delete: () => from(ref.delete()),\n    child: (path: string) => createStorageRef(ref.child(path), schedulers, keepUnstableUntilFirst),\n    updateMetadata: (meta: SettableMetadata) => from(ref.updateMetadata(meta)),\n    put: (data: any, metadata?: UploadMetadata) => {\n      const task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString: (data: string, format?: StringFormat, metadata?: UploadMetadata) => {\n      const task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    },\n    listAll: () => from(ref.listAll())\n  };\n}\n","import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';\nimport { createStorageRef } from './ref';\nimport { Observable } from 'rxjs';\nimport {\n  FIREBASE_APP_NAME,\n  FIREBASE_OPTIONS,\n  FirebaseAppConfig,\n  FirebaseOptions,\n  ɵAngularFireSchedulers,\n  ɵfetchInstance,\n  ɵfirebaseAppFactory,\n  ɵkeepUnstableUntilFirstFactory\n} from '@angular/fire';\nimport { UploadMetadata } from './interfaces';\nimport 'firebase/storage';\nimport firebase from 'firebase/app';\n\nexport const BUCKET = new InjectionToken<string>('angularfire2.storageBucket');\nexport const MAX_UPLOAD_RETRY_TIME = new InjectionToken<number>('angularfire2.storage.maxUploadRetryTime');\nexport const MAX_OPERATION_RETRY_TIME = new InjectionToken<number>('angularfire2.storage.maxOperationRetryTime');\n\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFireStorage {\n  public readonly storage: firebase.storage.Storage;\n\n  public readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n  public readonly schedulers: ɵAngularFireSchedulers;\n\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options: FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig: string | FirebaseAppConfig | null | undefined,\n    @Optional() @Inject(BUCKET) storageBucket: string | null,\n    // tslint:disable-next-line:ban-types\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone,\n    @Optional() @Inject(MAX_UPLOAD_RETRY_TIME) maxUploadRetryTime: number | any,\n    @Optional() @Inject(MAX_OPERATION_RETRY_TIME) maxOperationRetryTime: number | any,\n  ) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n    const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n\n    this.storage = ɵfetchInstance(`${app.name}.storage.${storageBucket}`, 'AngularFireStorage', app, () => {\n      const storage = zone.runOutsideAngular(() => app.storage(storageBucket || undefined));\n      if (maxUploadRetryTime) {\n        storage.setMaxUploadRetryTime(maxUploadRetryTime);\n      }\n      if (maxOperationRetryTime) {\n        storage.setMaxOperationRetryTime(maxOperationRetryTime);\n      }\n      return storage;\n    }, [maxUploadRetryTime, maxOperationRetryTime]);\n  }\n\n  ref(path: string) {\n    return createStorageRef(this.storage.ref(path), this.schedulers, this.keepUnstableUntilFirst);\n  }\n\n  refFromURL(path: string) {\n    return createStorageRef(this.storage.refFromURL(path), this.schedulers, this.keepUnstableUntilFirst);\n  }\n\n  upload(path: string, data: any, metadata?: UploadMetadata) {\n    const storageRef = this.storage.ref(path);\n    const ref = createStorageRef(storageRef, this.schedulers, this.keepUnstableUntilFirst);\n    return ref.put(data, metadata);\n  }\n\n}\n","import { AsyncPipe } from '@angular/common';\nimport { ChangeDetectorRef, NgModule, OnDestroy, Pipe, PipeTransform } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { AngularFireStorage } from '../storage';\n\n/** to be used with in combination with | async */\n@Pipe({\n  name: 'getDownloadURL',\n  pure: false,\n})\nexport class GetDownloadURLPipe implements PipeTransform, OnDestroy {\n\n  private asyncPipe: AsyncPipe;\n  private path: string;\n  private downloadUrl$: Observable<any>;\n\n  constructor(private storage: AngularFireStorage, cdr: ChangeDetectorRef) {\n    this.asyncPipe = new AsyncPipe(cdr);\n  }\n\n  transform(path: string) {\n    if (path !== this.path) {\n      this.path = path;\n      this.downloadUrl$ = this.storage.ref(path).getDownloadURL();\n    }\n    return this.asyncPipe.transform(this.downloadUrl$);\n  }\n\n  ngOnDestroy() {\n    this.asyncPipe.ngOnDestroy();\n  }\n\n}\n\n@NgModule({\n  declarations: [ GetDownloadURLPipe ],\n  exports: [ GetDownloadURLPipe ],\n})\nexport class GetDownloadURLPipeModule {}\n","import { NgModule } from '@angular/core';\nimport { GetDownloadURLPipeModule } from './pipes/storageUrl.pipe';\nimport { AngularFireStorage } from './storage';\n\n@NgModule({\n  exports: [ GetDownloadURLPipeModule ],\n  providers: [ AngularFireStorage ]\n})\nexport class AngularFireStorageModule { }\n"]},"metadata":{},"sourceType":"module"}